# CS305
###Summary of Client and Requirements
Artemis Financial is a consulting company that develops individualized financial plans for customers, including savings, retirement, investments, and insurance. As the client for Global Rain, a software engineering company specializing in custom software design, Artemis Financial wanted to modernize its operations and enhance software security. Specifically, they sought expertise to protect client data and financial information through a public web interface, including adding a file verification step with checksums for secure communications.
###Strengths in Addressing Vulnerabilities and Importance of Secure Coding
I effectively identified and addressed security vulnerabilities by recommending and deploying an appropriate encryption algorithm cipher, generating self-signed certificates, implementing cryptographic hash algorithms, and verifying secure communications via HTTPS. Secure coding is crucial because it prevents unauthorized access, data breaches, and exploitation of weaknesses that could lead to financial loss or reputational damage. It adds value to a company's well-being by ensuring compliance with security protocols, building customer trust, reducing legal risks, and maintaining operational integrity in an environment where data protection is paramount.
###Challenges and Helpful Aspects of Vulnerability Assessment
The most challenging part was iterating on the refactored code to eliminate errors and new vulnerabilities during secondary static testing with the dependency-check tool, as it required careful review to avoid introducing issues while enhancing security. However, the functional testing phase was helpful, as manually reviewing the code for syntactical, logical, and security flaws provided clear insights and allowed for targeted fixes, reinforcing my understanding of secure practices.
###Increasing Security Layers and Future Approaches
I increased security layers by refactoring the code to include an encryption cipher with hash functions, random numbers, and symmetric keys; generating certificates with Java Keytool; deploying checksum verification; switching to HTTPS; and conducting dependency checks and functional testing. In the future, I would use tools like dependency-check for static analysis, manual code reviews for functional testing, and vulnerability assessment processes to evaluate risks and select mitigation techniques such as algorithm updates or protocol enhancements based on identified threats.
###Ensuring Functionality and Security Post-Refactoring
To ensure the code and application were functional and secure, I compiled and ran the refactored code, verified checksums, and confirmed HTTPS functionality without errors. After refactoring, I checked for new vulnerabilities by running secondary static testing with dependency-check focused on added code and performing functional testing to iterate until no issues remained, ensuring the application complied with security enhancements.
###Resources, Tools, and Practices Used
I utilized Java Keytool for certificate generation, dependency-check for static testing, and Eclipse for code refactoring and execution. Coding practices included applying industry-standard best practices like using secure hash algorithms, random number generation, and protocol conversions (e.g., HTTP to HTTPS). These could be helpful in future tasks for maintaining security in software development, especially in agile environments.
###Examples for Future Employers
From this assignment, I could show employers the Practices for Secure Software Report, which details my process for refactoring code, adding security layers, and verifying compliance, along with screenshots of checksum verifications, secure webpages, and dependency-check outputs. Additionally, the zipped refactored code base demonstrates my hands-on skills in implementing encryption, certificates, and secure communications for a real-world financial application.
